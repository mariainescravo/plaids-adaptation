import pandas as pd
import numpy as np
from scipy.integrate import solve_ivp

def calc_bold_signal(neurons, results_coherent, results_incoherent, results_nonadap, T, dts, 
	dts_bold = 100, t0 = 0, t0adap = 6000):
	"""
	Calculates the blood-oxygen-level-dependent (BOLD) signal generated by the simulated 
	neuronal activity, using the Balloon-Windkessel model.

	Arguments:
		neurons (array): list of neurons to sum together, must match column names of results dataframes
		results (dataframe): pyrates-simulated activity of the circuit (columns = neurons, rows = timesteps)
		T (float): total integration time (ms)
		dts (float): sampling time step of simulated data
		dts_bold (float): sampling time step for BOLD solution (ms)
		t0 (float): beginning of simulation (ms)
		t0adap (float): beginning of adapting condition (ms)

	Returns:
		dataframe: summed activity of the selected neurons for each condition
		dataframe: BOLD signal for each condition
		dataframe: BOLD signal corrected for baseline activity (percent change)
	"""
	total_activity = calc_sum_activity(neurons,results_coherent,results_incoherent,results_nonadap)

	conditions = ['coherent','incoherent','nonadapting']
	index = np.arange(t0,T+dts_bold,dts_bold)
	bold_signal = pd.DataFrame(columns=conditions,index=index)
	bold_coherent   = _calc_non_linear_BOLD(total_activity['coherent'].values,T,dts,t0,dts_bold)[0]
	bold_incoherent = _calc_non_linear_BOLD(total_activity['incoherent'].values,T,dts,t0,dts_bold)[0]
	bold_nonadap    = _calc_non_linear_BOLD(total_activity['nonadapting'].values,T,dts,t0,dts_bold)[0]
	bold_signal.loc[:,('coherent')]    = bold_coherent
	bold_signal.loc[:,('incoherent')]  = bold_incoherent
	bold_signal.loc[:,('nonadapting')] = bold_nonadap

	baseline = bold_signal.loc[:int(t0adap),:]
	baseline = bold_signal.loc[:int(t0adap),:].mean()
	corrected_bold = (bold_signal - baseline)/baseline
	corrected_bold = corrected_bold.loc[int(t0adap):,:]
	corrected_bold = corrected_bold.set_index(bold_signal.index[:int((T-t0adap+dts_bold)/dts_bold)])

	return total_activity,bold_signal,corrected_bold

def calc_sum_activity(neurons, results_coherent, results_incoherent, results_nonadap):
	"""
	Calculates total activity of a list of neurons for each condition.

	Arguments:
		neurons (array): list of neurons to sum together, must match column names of results dataframes
		results (dataframe): pyrates-simulated activity of the circuit (columns = neurons, rows = timesteps)
		
	Returns:
		dataframe: summed activity for each condition (columns = conditions, rows = timesteps)
	"""
	coh     = results_coherent[neurons].sum(axis=1)
	incoh   = results_incoherent[neurons].sum(axis=1)
	nonadap = results_nonadap[neurons].sum(axis=1)
	conditions = ['coherent','incoherent','nonadapting']
	sum_activity = pd.DataFrame(columns=conditions,index=results_coherent.index)
	sum_activity.loc[:,('coherent')]    = coh
	sum_activity.loc[:,('incoherent')]  = incoh
	sum_activity.loc[:,('nonadapting')] = nonadap
	max_activity = sum_activity.max().max()
	#max_activity = len(results_coherent.columns)
	sum_activity *= 1.0/max_activity
	return sum_activity

def _calc_non_linear_BOLD(activity, T, dts, t0, dts_bold):
	"""
	Integrates differential equations of non-linear Balloon-Windkessel model,
	following the approach of Friston2003, Deco2013 and Cakan2021.

	Arguments:
		activity (array): total activity of a given condition
		T (float): total integration time (ms)
		dts (float): sampling time step of simulated data (ms)
		t0 (float): beginning of simulation (ms)
		dts_bold (float): sampling time step for BOLD solution (ms)

	Returns:
		dataframe: BOLD signal
	"""
	def z_function(t):
		return activity[int(t*1000/dts)]
	z = z_function

	k     = 0.65 # vasodilatory signal decay (1/s)
	gamma = 0.41 # rate constant for autoregulatory feedback by blood flow (1/s)
	tau   = 0.98 # transit time (s)
	alpha = 0.32 # Grubb's vessel stiffness exponent (dimensionless)
	rho   = 0.34 # capillary resting net oxygen extraction (dimensionless)
	params = [k,gamma,alpha,tau,rho]
	tspan = np.arange(t0/1000,T/1000+dts_bold/1000,dts_bold/1000)

	tinterval = [tspan[0],tspan[-1]]
	X0 = 0
	F0 = 1
	V0 = 1
	Q0 = 1
	Y0 = [X0,F0,V0,Q0]
	sol = solve_ivp(_balloon_windkessel_model, tinterval, Y0, t_eval = tspan, args = (z,params))
	x,f,v,q = sol.y
	v0 = 0.02
	k1 = 7 * rho
	k2 = 2
	k3 = 2 * rho - 2
	BOLD = v0 * (k1*(1-q) + k2*(1-q/v) + k3*(1-v))
	return BOLD,x,f,v,q

def _balloon_windkessel_model(t,Y,Z,params):
	X,F,V,Q = Y
	k,gamma,alpha,tau,rho = params
	dXdt = Z(t) - k*X - gamma*(F-1)
	dFdt = X
	dVdt = (F-V**(1.0/alpha))/tau
	dQdt = F/(rho*tau)*(1.0-(1.0-rho)**(1.0/F)) - Q*V**(1.0/alpha-1.0)/tau
	return np.single([dXdt,dFdt,dVdt,dQdt])




